# Отчет

## Объяснение алгоритма

KMP решает проблему неэффективного поиска подстроки, избегая возвратов в тексте при несовпадениях. Ключевая идея — использование информации о внутренней структуре паттерна через префикc функцию.

**Префикс функция (LPS):**

- Для каждой позиции `i` в паттерне хранит длину самого длинного собственного префикса, который также является суффиксом для подстроки `pattern[0..i]`
- Позволяет определить, на сколько позиций можно сдвинуть паттерн при несовпадении, не теряя уже проверенных символов

**Пример работы:**

Для паттерна `"ABABC"`:

- При несовпадении в позиции 4 (символ `'C'`), LPS[3] = 2 говорит, что можно сдвинуть паттерн так, чтобы префикс `"AB"` совпал с суффиксом `"AB"` предыдущего совпадения
- Это позволяет продолжить проверку с позиции 2 вместо полного возврата

Алгоритм работает в два прохода:

1. **Предобработка:** Вычисление LPS массива для паттерна за O(m)
2. **Поиск:** Использование LPS для эффективного поиска совпадений за O(n)

## Оценка сложности

**Временная сложность:**

- **Предобработка:** O(m), где m — длина паттерна
- **Поиск:** O(n), где n — длина текста
- **Итоговая:** O(n + m)

**Cложность по памяти:**

- O(m) для хранения LPS массива
- O(1) дополнительной памяти помимо входных данных и результата
